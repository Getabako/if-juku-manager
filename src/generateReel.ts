/**
 * リール（ショート動画）生成スクリプト
 *
 * 実行方法:
 * npm run generate:reel
 *
 * または特定のトピックIDを指定:
 * npx tsx src/generateReel.ts --topic=announcement-001
 *
 * 動的コンテンツ生成（デフォルト）:
 * npx tsx src/generateReel.ts
 */
import { bundle } from '@remotion/bundler';
import { renderMedia, selectComposition } from '@remotion/renderer';
import path from 'path';
import fs from 'fs/promises';
import { geminiGenerator } from './lib/geminiImageGenerator.js';
import { topicSelector } from './lib/topicSelector.js';
import { contentGenerator } from './lib/contentGenerator.js';
import { eventManager } from './lib/eventManager.js';
import { postHistory } from './lib/postHistory.js';
import { logger } from './lib/logger.js';
import { PATHS, IMAGE_SIZES } from './lib/config.js';
import type { ReelGenerationResult, Topic, Slide, CategoryType } from './lib/types.js';

// ロゴとサンクス画像のパス
const LOGO_PATH = path.join(PATHS.rawPhotos, 'logo.png');
const THANKS_IMAGE_PATH = path.join(PATHS.rawPhotos, 'ifjukuthanksreel.png');

// CI環境でのブラウザパス（GitHub Actions等）
const BROWSER_EXECUTABLE = process.env.PUPPETEER_EXECUTABLE_PATH || undefined;

/**
 * 画像ファイルをBase64データURLに変換
 * Remotionのブラウザはfile://プロトコルを許可しないため、Base64に変換
 */
async function imageToDataUrl(imagePath: string): Promise<string> {
  try {
    const absolutePath = path.resolve(imagePath);
    const imageBuffer = await fs.readFile(absolutePath);
    const base64 = imageBuffer.toString('base64');
    const ext = path.extname(imagePath).toLowerCase();
    const mimeType = ext === '.png' ? 'image/png' : 'image/jpeg';
    return `data:${mimeType};base64,${base64}`;
  } catch (error) {
    logger.error(`画像の読み込みに失敗: ${imagePath}`);
    throw error;
  }
}

interface GenerateReelOptions {
  topicId?: string;
  duration?: 15 | 30; // 秒数
  compositionId?: 'ReelVideo' | 'ReelVideoLong';
  category?: CategoryType; // 明示的にカテゴリを指定
  isAutoGenerated?: boolean; // 自動実行かどうか（履歴チェックを強化）
}

/**
 * リール動画を生成
 */
export async function generateReel(
  options: GenerateReelOptions = {}
): Promise<ReelGenerationResult> {
  const startTime = Date.now();
  logger.info('=== リール動画生成を開始 ===');

  const duration = options.duration || 15;
  const compositionId = duration === 30 ? 'ReelVideoLong' : 'ReelVideo';

  try {
    let slides: Slide[];
    let caption: string;
    let topicId: string;
    let category: CategoryType;
    let imagePrompts: string[] = [];
    let contentTitle: string = '';

    // 1. コンテンツを取得（動的 or 静的）
    if (options.topicId) {
      // 特定のトピックIDが指定された場合は静的トピックを使用
      const found = await topicSelector.getTopicById(options.topicId);
      if (!found) {
        throw new Error(`トピック "${options.topicId}" が見つかりません`);
      }
      slides = found.slides;
      caption = found.caption;
      topicId = found.id;
      category = found.category as CategoryType;
      contentTitle = found.title;
      logger.info(`静的トピックを使用: ${found.title}`);
    } else {
      // 動的コンテンツ生成（デフォルト）
      logger.info('Geminiで動的コンテンツを生成中...');

      // カテゴリを決定（指定がなければ曜日ベース）
      if (options.category) {
        category = options.category;
      } else {
        const todayCategory = await topicSelector.getTodayCategory();
        category = (todayCategory?.id as CategoryType) || 'ai';
      }

      logger.info(`カテゴリ: ${category}`);

      // カテゴリに応じた動的コンテンツを生成
      let content;
      const isAuto = options.isAutoGenerated || false;

      if (category === 'activity') {
        const report = await eventManager.getUnusedActivityReport();
        if (report) {
          const photoPaths = await eventManager.getPhotoPathsForReport(report);
          if (photoPaths.length > 0) {
            content = await contentGenerator.generateContent({
              category,
              isAutoGenerated: isAuto,
              photos: photoPaths.map(p => ({
                filename: path.basename(p),
                filepath: p,
                event: report.title,
                people: report.participants,
                expression: 'unknown',
                pose: 'unknown',
                description: report.description,
                category: 'activity'
              }))
            });
          } else {
            content = await contentGenerator.generateContent({ category, isAutoGenerated: isAuto });
          }
        } else {
          content = await contentGenerator.generateContent({ category, isAutoGenerated: isAuto });
        }
      } else if (category === 'announcement') {
        const announcement = await eventManager.getUnusedAnnouncement();
        if (announcement) {
          const topic = await eventManager.generateAnnouncementTopic(announcement);
          content = {
            title: topic.title,
            slides: topic.slides,
            caption: topic.caption,
            imagePrompts: []
          };
        } else {
          content = await contentGenerator.generateContent({ category, isAutoGenerated: isAuto });
        }
      } else {
        content = await contentGenerator.generateContent({ category, isAutoGenerated: isAuto });
      }

      slides = content.slides;
      caption = content.caption;
      imagePrompts = content.imagePrompts || [];
      topicId = `reel_${category}_${Date.now()}`;
      contentTitle = content.title;
      logger.success(`動的コンテンツ生成完了: ${contentTitle}`);
    }

    // 2. 背景画像を生成（リール用縦長）
    logger.info('リール用背景画像を準備中...');
    const backgroundImages: string[] = [];

    // スライド数分の背景を生成（最大3枚）
    const slidesToUse = slides.slice(0, 3);

    // コンテンツ固有の画像プロンプトがあれば使用
    if (imagePrompts.length > 0) {
      for (let i = 0; i < Math.min(slidesToUse.length, imagePrompts.length); i++) {
        const prompt = imagePrompts[i];

        // USE_PHOTO: プレフィックスがある場合は実際の写真を使用
        if (prompt && prompt.startsWith('USE_PHOTO:')) {
          const parts = prompt.split(':');
          const photoPath = parts[1];
          logger.info(`実際の写真を使用: ${path.basename(photoPath)}`);
          // 写真を元にスタイライズした背景を生成
          const result = await geminiGenerator.generateFromReference(photoPath, category);
          if (result.success && result.imagePath) {
            backgroundImages.push(result.imagePath);
          } else {
            // フォールバック：元の写真をそのまま使用
            backgroundImages.push(photoPath);
          }
          await delay(1000);
        } else if (prompt && prompt !== '実際の写真を使用するため不要') {
          // 具体的なプロンプトから画像を生成
          logger.info(`コンテンツ連動画像を生成: ${prompt.slice(0, 50)}...`);
          const result = await geminiGenerator.generateContentSpecificBackground(prompt, 'reel');
          if (result.success && result.imagePath) {
            backgroundImages.push(result.imagePath);
          }
          await delay(1000);
        }
      }
    }

    // 足りない分はカテゴリ別のデフォルト背景を生成
    while (backgroundImages.length < slidesToUse.length) {
      logger.info(`追加の背景画像を生成中... (${backgroundImages.length + 1}/${slidesToUse.length})`);
      const result = await geminiGenerator.generateReelBackground(category);
      if (result.success && result.imagePath) {
        backgroundImages.push(result.imagePath);
      }
      await delay(1000); // レート制限対策
    }

    logger.success(`${backgroundImages.length} 枚の背景画像を準備しました`);

    // 3. 画像をBase64データURLに変換（file://プロトコル問題を回避）
    logger.info('画像をBase64に変換中...');
    const backgroundDataUrls = await Promise.all(
      backgroundImages.map((img) => imageToDataUrl(img))
    );
    const logoDataUrl = await imageToDataUrl(LOGO_PATH);
    const thanksDataUrl = await imageToDataUrl(THANKS_IMAGE_PATH);
    logger.success('画像の変換完了');

    // 4. Remotion でバンドルを作成
    logger.info('Remotion バンドルを作成中...');
    const bundleLocation = await bundle({
      entryPoint: path.resolve('./src/remotion/index.ts'),
      webpackOverride: (config) => config,
    });

    // 5. コンポジションを選択
    const inputProps = {
      slides: slidesToUse,
      backgroundImages: backgroundDataUrls,
      logoPath: logoDataUrl,
      thanksImagePath: thanksDataUrl,
    };

    const composition = await selectComposition({
      serveUrl: bundleLocation,
      id: compositionId,
      inputProps,
      browserExecutable: BROWSER_EXECUTABLE,
    });

    // 6. 動画をレンダリング
    const outputDir = path.join(PATHS.generated, topicId);
    await fs.mkdir(outputDir, { recursive: true });

    const outputPath = path.join(outputDir, `reel_${duration}s.mp4`);

    logger.info(`動画をレンダリング中... (${duration}秒)`);
    await renderMedia({
      composition,
      serveUrl: bundleLocation,
      codec: 'h264',
      outputLocation: outputPath,
      inputProps,
      browserExecutable: BROWSER_EXECUTABLE,
    });

    const durationTime = ((Date.now() - startTime) / 1000).toFixed(1);
    logger.success(`=== リール動画生成完了 (${durationTime}秒) ===`);

    const result: ReelGenerationResult = {
      topicId,
      videoPath: outputPath,
      caption,
      generatedAt: new Date(),
    };

    logger.info(`出力ファイル: ${outputPath}`);

    // 自動実行時は履歴に保存
    if (options.isAutoGenerated) {
      await postHistory.addPost({
        category,
        title: contentTitle,
        topic: contentTitle,
        slides: slides.slice(0, 3).map(s => ({
          headline: s.headline,
          points: s.points,
        })),
        caption,
        outputPath,
        isAutoGenerated: true,
        executionTime: postHistory.getExecutionTime(),
      });
    }

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : '不明なエラー';
    logger.error(`リール生成エラー: ${errorMessage}`);
    throw error;
  }
}

function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * コマンドライン引数を解析
 */
function parseArgs(): GenerateReelOptions {
  const args = process.argv.slice(2);
  const options: GenerateReelOptions = {};

  for (const arg of args) {
    if (arg.startsWith('--topic=')) {
      options.topicId = arg.split('=')[1];
    }
    if (arg === '--long' || arg === '--30s') {
      options.duration = 30;
    }
  }

  return options;
}

// 直接実行された場合
const isMainModule = import.meta.url === `file://${process.argv[1]}`;

if (isMainModule) {
  const options = parseArgs();

  generateReel(options)
    .then((result) => {
      console.log('\n--- 生成結果 ---');
      console.log(`トピックID: ${result.topicId}`);
      console.log(`動画ファイル: ${result.videoPath}`);
      console.log('\nキャプション:');
      console.log(result.caption);
      process.exit(0);
    })
    .catch((error) => {
      console.error('エラーが発生しました:', error.message);
      process.exit(1);
    });
}
