/**
 * 投稿履歴管理モジュール
 * 自動実行時に過去の投稿を参照して重複を避ける
 */
import fs from 'fs/promises';
import path from 'path';
import { PATHS } from './config.js';
import { logger } from './logger.js';
import type { CategoryType, Slide } from './types.js';

// 投稿履歴のエントリー
export interface PostHistoryEntry {
  id: string;
  generatedAt: string;
  category: CategoryType;
  title: string;
  topic: string;
  slides: {
    headline: string;
    points?: string[];
  }[];
  caption: string;
  outputPath: string;
  isAutoGenerated: boolean;
  executionTime: 'morning' | 'evening' | 'manual';
  // 拡張フィールド
  topicId?: string;        // トピックID
  imageUrls?: string[];    // 画像URL一覧
  newsSource?: string;     // ニュースソース（ブログ先行型の場合）
  blogPath?: string;       // ブログファイルパス
}

// 投稿履歴ファイル
interface PostHistoryFile {
  version: string;
  lastUpdated: string;
  totalPosts: number;
  posts: PostHistoryEntry[];
}

const HISTORY_FILE_PATH = path.join(PATHS.data, 'post-history.json');

class PostHistoryManager {
  private history: PostHistoryFile | null = null;

  /**
   * 履歴ファイルを読み込む
   */
  async loadHistory(): Promise<PostHistoryFile> {
    if (this.history) {
      return this.history;
    }

    try {
      const data = await fs.readFile(HISTORY_FILE_PATH, 'utf-8');
      this.history = JSON.parse(data) as PostHistoryFile;
      logger.info(`投稿履歴を読み込み: ${this.history.totalPosts}件`);
      return this.history;
    } catch (error) {
      // ファイルが存在しない場合は新規作成
      logger.info('投稿履歴ファイルを新規作成');
      this.history = {
        version: '1.0.0',
        lastUpdated: new Date().toISOString(),
        totalPosts: 0,
        posts: [],
      };
      return this.history;
    }
  }

  /**
   * 履歴を保存
   */
  async saveHistory(): Promise<void> {
    if (!this.history) {
      return;
    }

    this.history.lastUpdated = new Date().toISOString();
    this.history.totalPosts = this.history.posts.length;

    await fs.writeFile(
      HISTORY_FILE_PATH,
      JSON.stringify(this.history, null, 2),
      'utf-8'
    );
    logger.success(`投稿履歴を保存: ${this.history.totalPosts}件`);
  }

  /**
   * 新しい投稿を履歴に追加
   */
  async addPost(entry: Omit<PostHistoryEntry, 'id' | 'generatedAt'>): Promise<void> {
    await this.loadHistory();

    const newEntry: PostHistoryEntry = {
      ...entry,
      id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      generatedAt: new Date().toISOString(),
    };

    this.history!.posts.unshift(newEntry); // 新しい投稿を先頭に追加
    await this.saveHistory();

    logger.info(`投稿履歴に追加: ${entry.title} (${entry.category})`);
  }

  /**
   * カテゴリ別の過去の投稿を取得
   */
  async getPostsByCategory(category: CategoryType, limit: number = 30): Promise<PostHistoryEntry[]> {
    await this.loadHistory();
    return this.history!.posts
      .filter(p => p.category === category)
      .slice(0, limit);
  }

  /**
   * 最近の投稿を取得
   */
  async getRecentPosts(days: number = 30): Promise<PostHistoryEntry[]> {
    await this.loadHistory();
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);

    return this.history!.posts.filter(p => {
      const postDate = new Date(p.generatedAt);
      return postDate >= cutoffDate;
    });
  }

  /**
   * 過去のトピック一覧を取得（重複チェック用）
   */
  async getPastTopics(category: CategoryType, days: number = 90): Promise<string[]> {
    const recentPosts = await this.getPostsByCategory(category, 100);
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);

    return recentPosts
      .filter(p => new Date(p.generatedAt) >= cutoffDate)
      .map(p => p.topic.toLowerCase());
  }

  /**
   * トピックが過去に使用されたかチェック
   */
  async isTopicUsed(topic: string, category: CategoryType, days: number = 30): Promise<boolean> {
    const pastTopics = await this.getPastTopics(category, days);
    const topicLower = topic.toLowerCase();

    // 完全一致または部分一致（80%以上の類似度）をチェック
    return pastTopics.some(past => {
      if (past === topicLower) return true;
      // 簡易的な類似度チェック（共通キーワード）
      const topicWords = new Set(topicLower.split(/\s+/));
      const pastWords = new Set(past.split(/\s+/));
      let common = 0;
      topicWords.forEach(w => { if (pastWords.has(w)) common++; });
      return common / Math.max(topicWords.size, pastWords.size) > 0.6;
    });
  }

  /**
   * 過去の投稿情報をコンテンツ生成に渡すための要約を取得
   */
  async getHistorySummaryForGeneration(category: CategoryType): Promise<string> {
    const recentPosts = await this.getPostsByCategory(category, 20);

    if (recentPosts.length === 0) {
      return '過去の投稿履歴はありません。';
    }

    const summary = recentPosts.map((p, i) => {
      const date = new Date(p.generatedAt).toLocaleDateString('ja-JP');
      return `${i + 1}. [${date}] ${p.title} - トピック: ${p.topic}`;
    }).join('\n');

    return `【過去${recentPosts.length}件の${category}カテゴリ投稿】
${summary}

※上記と重複しない新しいトピックを選択してください。`;
  }

  /**
   * 今日の投稿数を取得
   */
  async getTodayPostCount(): Promise<{ total: number; byCategory: Record<string, number> }> {
    await this.loadHistory();

    const today = new Date().toDateString();
    const todayPosts = this.history!.posts.filter(p => {
      return new Date(p.generatedAt).toDateString() === today;
    });

    const byCategory: Record<string, number> = {};
    todayPosts.forEach(p => {
      byCategory[p.category] = (byCategory[p.category] || 0) + 1;
    });

    return {
      total: todayPosts.length,
      byCategory,
    };
  }

  /**
   * 自動実行用: 実行時間を判定
   */
  getExecutionTime(): 'morning' | 'evening' | 'manual' {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) {
      return 'morning';
    } else if (hour >= 17 && hour < 23) {
      return 'evening';
    }
    return 'manual';
  }

  /**
   * 統計情報を取得
   */
  async getStatistics(): Promise<{
    totalPosts: number;
    postsByCategory: Record<string, number>;
    postsLast7Days: number;
    postsLast30Days: number;
  }> {
    await this.loadHistory();

    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const postsByCategory: Record<string, number> = {};
    let postsLast7Days = 0;
    let postsLast30Days = 0;

    this.history!.posts.forEach(p => {
      postsByCategory[p.category] = (postsByCategory[p.category] || 0) + 1;
      const postDate = new Date(p.generatedAt);
      if (postDate >= oneWeekAgo) postsLast7Days++;
      if (postDate >= oneMonthAgo) postsLast30Days++;
    });

    return {
      totalPosts: this.history!.totalPosts,
      postsByCategory,
      postsLast7Days,
      postsLast30Days,
    };
  }
}

export const postHistory = new PostHistoryManager();
